#include "cache.h"
#include <unordered_map>
#include <tuple>
#include <iostream>
#include <algorithm>
#include <array>
#include <vector>

#define trace_total_count 500000

static long long int trace_count = 0;
static int sanity = 0;
static int i = 0;
static int flag = 0;
// int64_t globalStride1 = 0;
// int64_t globalStride2 = 0;
// int64_t globalStride3 = 0;
// int64_t globalStride4 = 0;
// int64_t globalStride5 = 0;
// int64_t globalStride6 = 0;
// int64_t globalStride7 = 0;
// int64_t globalStride8 = 0;

static std::array<int64_t, 16> globalStrides = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; // CHANGED

static long long int n_total = 0;
static long long int prefetched = 1; // changed
static long long int matched = 0;

static std::array<uint64_t, 21> prev_addrs1 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; // CHANGED

struct TrieNode
{
    std::unordered_map<int64_t, TrieNode *> children;
    int count = 0;                  // Count for last element
    long double maxPotential = 0.0; // Best arm for 3rd element
    long double potential = 0.0;    // Potential for last element

    int numberOfTimesPicked = 1; // Times picked for prefetching
    int reward = 0;              // Added

    std::vector<std::pair<std::tuple<int64_t, int64_t, int64_t, int64_t>, int>> nextFourElementsSummary;

    ~TrieNode()
    {
        for (auto &child : children)
        {
            delete child.second;
        }
    }
};

TrieNode *globalGroupRootNode = nullptr; // This remains unchanged
// Updated to hold a pointer to a tuple of the next three elements
std::tuple<int64_t, int64_t, int64_t, int64_t> *globalNextFourElements = nullptr;

class GroupTrie
{
private:
    TrieNode *root;

public:
    GroupTrie() : root(new TrieNode()) {}

    ~GroupTrie()
    {
        delete root; // Ensure we clean up memory on destruction
    }

    // For DUCB
    // void updateNumberOfTimesPicked(TrieNode *node, int depth = 0)
    // {
    //     // Base case: If the node is null or we have reached the 6th element (3 levels deeper from the 3rd element)
    //     if (!node || depth == 3)
    //     {
    //         if (node)
    //         {
    //             // Update numberOfTimesPicked for the 6th element
    //             node->numberOfTimesPicked *= 0.99;
    //         }
    //         return; // Stop the recursion
    //     }

    //     // Recursive case: Traverse all children of the current node
    //     for (auto &child : node->children)
    //     {
    //         // Recursive call to the child with incremented depth
    //         updateNumberOfTimesPicked(child.second, depth + 1);
    //     }
    // }

    void update20thNodePotential(TrieNode *node, int depth = 0)
    {
        if (!node)
            return; // Base case

        // At the 12th node (4 levels down from groupRootNode = 8th node)
        if (depth == 4)
        {
            if (node->numberOfTimesPicked > 0 && node->count > 0 && prefetched > 0)
            {
                node->potential = 0.04 * sqrt(node->count) + 0.04 * sqrt(log(prefetched) / node->numberOfTimesPicked) + node->reward;
                return;
            }
        }

        // Recursive case: Traverse all children
        for (auto &child : node->children)
        {
            update20thNodePotential(child.second, depth + 1);
        }
    }

    void updateGroupRootNode(TrieNode *groupRootNode)
    {
        double maxPotential = 0.0;
        std::tuple<int64_t, int64_t, int64_t, int64_t> bestGroup;
        int bestGroupCount = 0;

        // Assuming groupRootNode points to the node for the 3rd element
        for (auto &child1 : groupRootNode->children)
        {
            for (auto &child2 : child1.second->children)
            {
                for (auto &child3 : child2.second->children)
                {
                    // Check if this child's (representing the 6th element) potential is the highest found
                    for (auto &child4 : child3.second->children)
                    {
                        if (child4.second->potential > maxPotential)
                        {
                            maxPotential = child4.second->potential;
                            bestGroup = std::make_tuple(child1.first, child2.first, child3.first, child4.first);
                            bestGroupCount = child4.second->count;
                        }
                    }
                }
            }
        }

        // Update the groupRootNode with the found best group details
        groupRootNode->maxPotential = maxPotential;
        if (maxPotential > 0)
        {                                                   // Check ensures we have a meaningful update
            groupRootNode->nextFourElementsSummary.clear(); // Clear existing summaries if needed
            groupRootNode->nextFourElementsSummary.push_back({bestGroup, bestGroupCount});
        }
    }

    void insert(const std::tuple<int64_t, int64_t, int64_t, int64_t, int64_t, int64_t, int64_t, int64_t, int64_t, int64_t, int64_t, int64_t, int64_t, int64_t, int64_t, int64_t, int64_t, int64_t, int64_t, int64_t> &group)
    {
        TrieNode *node = root;
        std::vector<TrieNode *> visitedNodes; // To enable backtracking
        auto [one, two, three, four, five, six, seven, eight, nine, ten, eleven, twelve, thirteen, fourteen, fifteen, sixteen, seventeen, eighteen, nineteen, twenty] = group;
        std::array<int64_t, 20> elements = {one, two, three, four, five, six, seven, eight, nine, ten, eleven, twelve, thirteen, fourteen, fifteen, sixteen, seventeen, eighteen, nineteen, twenty};

        for (int i = 0; i < elements.size(); ++i)
        {
            int64_t element = elements[i];
            if (node->children.find(element) == node->children.end())
            {
                node->children[element] = new TrieNode();
            }
            visitedNodes.push_back(node); // Add current node to visited for backtracking
            node = node->children[element];
        }
        node->count++;        // Increment the count at the final node
        if (node->count == 1) // Updating number of unique groups
        {
            n_total++;
        }
        if (node->numberOfTimesPicked > 0 && node->count > 0 && prefetched > 0)
            node->potential = 0.04 * sqrt(log(node->count)) + 0.04 * sqrt(log(prefetched) / node->numberOfTimesPicked) + node->reward;

        // std::cout << "Inserted" << std::endl;

        // Update the summary for the third element node with the next three elements
        if (visitedNodes.size() > 16) // Ensure there's a third element node
        {
            TrieNode *eighthElementNode = visitedNodes[16]; // Third element is at index 2
            // std::cout << "Inside if" << std::endl;

            // Check if it's necessary to update the nextFourElementsSummary
            if (eighthElementNode->nextFourElementsSummary.empty() || eighthElementNode->maxPotential <= node->potential)
            {
                // std::cout << "Updating summary" << std::endl;
                eighthElementNode->nextFourElementsSummary = {{std::make_tuple(seventeen, eighteen, nineteen, twenty), node->count}};
                eighthElementNode->maxPotential = node->potential; // Update the max count for the subtree
            }
        }

        // NOT REQUIRED
        // // Backtrack to update maxPotential for all nodes in the path
        // for (auto it = visitedNodes.rbegin(); it != visitedNodes.rend(); ++it)
        // {
        //     TrieNode *currentNode = *it;
        //     currentNode->maxPotential = std::max(currentNode->maxPotential, node->potential);
        // }
    }

    void queryNextElementsForHighestCountGroup(int64_t firstElement, int64_t secondElement, int64_t thirdElement, int64_t fourthElement, int64_t fifthElement, int64_t sixthElement, int64_t seventhElement, int64_t eighthElement, int64_t ninthElement, int64_t tenthElement, int64_t eleventhElement, int64_t twelfthElement, int64_t thirteenthElement, int64_t fourteenthElement, int64_t fifteenthElement, int64_t sixteenthElement)
    {
        TrieNode *node = root;
        TrieNode *groupRootNode = nullptr;

        if (node->children.find(firstElement) != node->children.end())
        {
            node = node->children[firstElement];
            if (node->children.find(secondElement) != node->children.end())
            {
                node = node->children[secondElement];
                if (node->children.find(thirdElement) != node->children.end())
                {
                    node = node->children[thirdElement];
                    if (node->children.find(fourthElement) != node->children.end())
                    {
                        node = node->children[fourthElement];
                        if (node->children.find(fifthElement) != node->children.end())
                        {
                            node = node->children[fifthElement];
                            if (node->children.find(sixthElement) != node->children.end())
                            {
                                node = node->children[sixthElement];
                                if (node->children.find(seventhElement) != node->children.end())
                                {
                                    node = node->children[seventhElement];
                                    if (node->children.find(eighthElement) != node->children.end())
                                    {
                                        node = node->children[eighthElement];
                                        if (node->children.find(ninthElement) != node->children.end())
                                        {
                                            node = node->children[ninthElement];
                                            if (node->children.find(tenthElement) != node->children.end())
                                            {
                                                node = node->children[tenthElement];
                                                if (node->children.find(eleventhElement) != node->children.end())
                                                {
                                                    node = node->children[eleventhElement];
                                                    if (node->children.find(twelfthElement) != node->children.end())
                                                    {
                                                        node = node->children[twelfthElement];
                                                        if (node->children.find(thirteenthElement) != node->children.end())
                                                        {
                                                            node = node->children[thirteenthElement];
                                                            if (node->children.find(fourteenthElement) != node->children.end())
                                                            {
                                                                node = node->children[fourteenthElement];
                                                                if (node->children.find(fifteenthElement) != node->children.end())
                                                                {
                                                                    node = node->children[fifteenthElement];
                                                                    if (node->children.find(sixteenthElement) != node->children.end())
                                                                    {
                                                                        node = node->children[sixteenthElement];

                                                                        groupRootNode = node;

                                                                        if (!node->nextFourElementsSummary.empty())
                                                                        {
                                                                            auto &summary = node->nextFourElementsSummary[0];
                                                                            if (summary.second > 200)
                                                                            {
                                                                                globalGroupRootNode = groupRootNode;

                                                                                delete globalNextFourElements;
                                                                                globalNextFourElements = new std::tuple<int64_t, int64_t, int64_t, int64_t>(std::get<0>(summary.first), std::get<1>(summary.first), std::get<2>(summary.first), std::get<3>(summary.first));

                                                                                groupRootNode->children[std::get<0>(summary.first)]->children[std::get<1>(summary.first)]->children[std::get<2>(summary.first)]->children[std::get<3>(summary.first)]->numberOfTimesPicked++;
                                                                            }
                                                                            else
                                                                            {
                                                                                globalGroupRootNode = nullptr;
                                                                                delete globalNextFourElements;
                                                                                globalNextFourElements = nullptr;
                                                                            }
                                                                        }
                                                                        else
                                                                        {
                                                                            globalGroupRootNode = nullptr;
                                                                            delete globalNextFourElements;
                                                                            globalNextFourElements = nullptr;
                                                                        }
                                                                    }
                                                                    else
                                                                    {
                                                                        globalGroupRootNode = nullptr;
                                                                        delete globalNextFourElements;
                                                                        globalNextFourElements = nullptr;
                                                                    }
                                                                }
                                                                else
                                                                {
                                                                    globalGroupRootNode = nullptr;
                                                                    delete globalNextFourElements;
                                                                    globalNextFourElements = nullptr;
                                                                }
                                                            }
                                                            else
                                                            {
                                                                globalGroupRootNode = nullptr;
                                                                delete globalNextFourElements;
                                                                globalNextFourElements = nullptr;
                                                            }
                                                        }
                                                        else
                                                        {
                                                            globalGroupRootNode = nullptr;
                                                            delete globalNextFourElements;
                                                            globalNextFourElements = nullptr;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        globalGroupRootNode = nullptr;
                                                        delete globalNextFourElements;
                                                        globalNextFourElements = nullptr;
                                                    }
                                                }
                                                else
                                                {
                                                    globalGroupRootNode = nullptr;
                                                    delete globalNextFourElements;
                                                    globalNextFourElements = nullptr;
                                                }
                                            }
                                            else
                                            {
                                                globalGroupRootNode = nullptr;
                                                delete globalNextFourElements;
                                                globalNextFourElements = nullptr;
                                            }
                                        }
                                        else
                                        {
                                            globalGroupRootNode = nullptr;
                                            delete globalNextFourElements;
                                            globalNextFourElements = nullptr;
                                        }
                                    }
                                    else
                                    {
                                        globalGroupRootNode = nullptr;
                                        delete globalNextFourElements;
                                        globalNextFourElements = nullptr;
                                    }
                                }
                                else
                                {
                                    globalGroupRootNode = nullptr;
                                    delete globalNextFourElements;
                                    globalNextFourElements = nullptr;
                                }
                            }
                            else
                            {
                                globalGroupRootNode = nullptr;
                                delete globalNextFourElements;
                                globalNextFourElements = nullptr;
                            }
                        }
                        else
                        {
                            globalGroupRootNode = nullptr;
                            delete globalNextFourElements;
                            globalNextFourElements = nullptr;
                        }
                    }
                    else
                    {
                        globalGroupRootNode = nullptr;
                        delete globalNextFourElements;
                        globalNextFourElements = nullptr;
                    }
                }
                else
                {
                    globalGroupRootNode = nullptr;
                    delete globalNextFourElements;
                    globalNextFourElements = nullptr;
                }
            }
            else
            {
                globalGroupRootNode = nullptr;
                delete globalNextFourElements;
                globalNextFourElements = nullptr;
            }
        }
        else
        {
            globalGroupRootNode = nullptr;
            delete globalNextFourElements;
            globalNextFourElements = nullptr;
        }
    }

    void incrementReward(TrieNode *groupRootNode, const std::tuple<int64_t, int64_t, int64_t, int64_t> &nextFourElements)
    {
        if (!groupRootNode)
            return;

        // Update to handle the three elements following the initial group
        std::array<int64_t, 4> elements = {std::get<0>(nextFourElements), std::get<1>(nextFourElements), std::get<2>(nextFourElements), std::get<3>(nextFourElements)};
        // std::vector<TrieNode *> path;

        TrieNode *node = groupRootNode;
        for (int64_t element : elements)
        {
            if (node->children.find(element) == node->children.end())
            {
                // The complete group does not exist
                return;
            }
            // path.push_back(node); // Track the path for updating ancestors
            node = node->children[element];
        }
        node->reward++; // Increment the count at the final node of the group
        // std::cout << "Incremented" << std::endl;

        // // Update maxPotential for all ancestor nodes
        // for (TrieNode *ancestor : path)
        // {
        //     ancestor->maxPotential = std::max(ancestor->maxPotential, node->count);
        // }
    }

    void decrementReward(TrieNode *groupRootNode, const std::tuple<int64_t, int64_t, int64_t, int64_t> &nextFourElements)
    {
        if (!groupRootNode)
            return;

        // Update to handle the three elements following the initial group
        std::array<int64_t, 4> elements = {std::get<0>(nextFourElements), std::get<1>(nextFourElements), std::get<2>(nextFourElements), std::get<3>(nextFourElements)};
        // std::vector<TrieNode *> path;

        TrieNode *node = groupRootNode;
        for (int64_t element : elements)
        {
            if (node->children.find(element) == node->children.end())
            {
                // The complete group does not exist
                return;
            }
            // path.push_back(node); // Track the path for updating ancestors
            node = node->children[element];
        }

        // Decrement the count at the final node of the group
        if (node->count > 0)

        { // Ensure the count doesn't go negative
            node->reward--;
        }
        // std::cout << "Decremented" << std::endl;

        // Update maxPotential for all ancestor nodes, including the last
        // for (TrieNode *ancestor : path)
        // {
        //     if (ancestor->maxPotential > 0)
        //     {
        //         ancestor->maxPotential = std::max(ancestor->maxPotential, node->count);
        //     }
        // }
    }
};

GroupTrie trie;

void CACHE::l1d_prefetcher_initialize()
{
}

void CACHE::l1d_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint8_t critical_ip_flag)
{

    if (warmup_complete[0])
    { // Inserting into trie
        if (trace_count <= trace_total_count)
        {
            uint64_t temp_addr = addr >> LOG2_BLOCK_SIZE;

            // Update and rotate previous addresses
            std::rotate(prev_addrs1.begin(), prev_addrs1.begin() + 1, prev_addrs1.end());
            prev_addrs1.back() = temp_addr;

            // Check if we have enough addresses to calculate differences
            if (prev_addrs1[0] != 0 && trace_count >= 20)
            {
                // Calculate differences
                auto diff = std::make_tuple(
                    prev_addrs1[1] - prev_addrs1[0],
                    prev_addrs1[2] - prev_addrs1[1],
                    prev_addrs1[3] - prev_addrs1[2],
                    prev_addrs1[4] - prev_addrs1[3],
                    prev_addrs1[5] - prev_addrs1[4],
                    prev_addrs1[6] - prev_addrs1[5],
                    prev_addrs1[7] - prev_addrs1[6],
                    prev_addrs1[8] - prev_addrs1[7],
                    prev_addrs1[9] - prev_addrs1[8],
                    prev_addrs1[10] - prev_addrs1[9],
                    prev_addrs1[11] - prev_addrs1[10],
                    prev_addrs1[12] - prev_addrs1[11],
                    prev_addrs1[13] - prev_addrs1[12],
                    prev_addrs1[14] - prev_addrs1[13],
                    prev_addrs1[15] - prev_addrs1[14],
                    prev_addrs1[16] - prev_addrs1[15],
                    prev_addrs1[17] - prev_addrs1[16],
                    prev_addrs1[18] - prev_addrs1[17],
                    prev_addrs1[19] - prev_addrs1[18],
                    prev_addrs1[20] - prev_addrs1[19]);

                // Check if any difference is non-zero before inserting
                bool nonZeroDifference = (std::get<0>(diff) != 0 || std::get<1>(diff) != 0 || std::get<2>(diff) != 0 || std::get<3>(diff) != 0 ||
                                          std::get<4>(diff) != 0 || std::get<5>(diff) != 0 || std::get<6>(diff) != 0 || std::get<7>(diff) != 0 ||
                                          std::get<8>(diff) != 0 || std::get<9>(diff) != 0 || std::get<10>(diff) != 0 || std::get<11>(diff) != 0 ||
                                          std::get<12>(diff) != 0 || std::get<13>(diff) != 0 || std::get<14>(diff) != 0 || std::get<15>(diff) != 0);

                if (nonZeroDifference)
                {
                    trie.insert(diff);
                }
            }

            trace_count++;

            return;
        }

        static uint64_t temp1 = 0;
        static uint64_t temp2 = 0;
        static uint64_t temp3 = 0;
        static int64_t stride1 = 0;
        static int64_t stride2 = 0;
        static int64_t stride3 = 0;
        static uint64_t temp_addr = 0;
        static uint64_t prefetch1 = 0;
        static uint64_t prefetch2 = 0;
        static uint64_t prefetch3 = 0;
        static uint64_t prefetch4 = 0;

        static uint64_t temp4 = 0;
        static uint64_t temp5 = 0;
        static uint64_t temp6 = 0;
        static uint64_t temp7 = 0;
        static uint64_t temp8 = 0;
        static uint64_t temp9 = 0;
        static uint64_t temp10 = 0;
        static uint64_t temp11 = 0;
        static uint64_t temp12 = 0;
        static uint64_t temp13 = 0;
        static uint64_t temp14 = 0;
        static uint64_t temp15 = 0;
        static uint64_t temp16 = 0;

        static int64_t stride4 = 0;
        static int64_t stride5 = 0;
        static int64_t stride6 = 0;
        static int64_t stride7 = 0;
        static int64_t stride8 = 0;
        static int64_t stride9 = 0;
        static int64_t stride10 = 0;
        static int64_t stride11 = 0;
        static int64_t stride12 = 0;
        static int64_t stride13 = 0;
        static int64_t stride14 = 0;
        static int64_t stride15 = 0;
        static int64_t stride16 = 0;

        if (sanity == 0)
        {
            if (temp1 == 0)
            {
                temp1 = addr >> LOG2_BLOCK_SIZE;
                return;
            }
            else if (temp2 == 0)
            {
                temp2 = addr >> LOG2_BLOCK_SIZE;
                return;
            }
            else if (temp3 == 0)
            {
                temp3 = addr >> LOG2_BLOCK_SIZE;
                return;
            }
            else if (temp4 == 0)
            {
                temp4 = addr >> LOG2_BLOCK_SIZE;
                return;
            }
            else if (temp5 == 0)
            {
                temp5 = addr >> LOG2_BLOCK_SIZE;
                return;
            }
            else if (temp6 == 0)
            {
                temp6 = addr >> LOG2_BLOCK_SIZE;
                return;
            }
            else if (temp7 == 0)
            {
                temp7 = addr >> LOG2_BLOCK_SIZE;
                return;
            }
            else if (temp8 == 0)
            {
                temp8 = addr >> LOG2_BLOCK_SIZE;
                return;
            }
            else if (temp9 == 0)
            {
                temp9 = addr >> LOG2_BLOCK_SIZE;
                return;
            }
            else if (temp10 == 0)
            {
                temp10 = addr >> LOG2_BLOCK_SIZE;
                return;
            }
            else if (temp11 == 0)
            {
                temp11 = addr >> LOG2_BLOCK_SIZE;
                return;
            }
            else if (temp12 == 0)
            {
                temp12 = addr >> LOG2_BLOCK_SIZE;
                return;
            }
            else if (temp13 == 0)
            {
                temp13 = addr >> LOG2_BLOCK_SIZE;
                return;
            }
            else if (temp14 == 0)
            {
                temp14 = addr >> LOG2_BLOCK_SIZE;
                return;
            }
            else if (temp15 == 0)
            {
                temp15 = addr >> LOG2_BLOCK_SIZE;
                return;
            }
            else if (temp16 == 0)
            {
                temp16 = addr >> LOG2_BLOCK_SIZE;
                return;
            }
            else
            {
                temp_addr = addr >> LOG2_BLOCK_SIZE;
                stride1 = temp2 - temp1;
                stride2 = temp3 - temp2;
                stride3 = temp4 - temp3;
                stride4 = temp5 - temp4;
                stride5 = temp6 - temp5;
                stride6 = temp7 - temp6;
                stride7 = temp8 - temp7;
                stride8 = temp9 - temp8;
                stride9 = temp10 - temp9;
                stride10 = temp11 - temp10;
                stride11 = temp12 - temp11;
                stride12 = temp13 - temp12;
                stride13 = temp14 - temp13;
                stride14 = temp15 - temp14;
                stride15 = temp16 - temp15;
                stride16 = temp_addr - temp16;

                temp1 = temp_addr;
                temp5 = temp_addr; // Change

                temp2 = 0;
                temp3 = 0;
                temp4 = 0;
                temp6 = 0;
                temp7 = 0;
                temp8 = 0;
                temp9 = 0;
                temp10 = 0;
                temp11 = 0;
                temp12 = 0;
                temp13 = 0;
                temp14 = 0;
                temp15 = 0;
                temp16 = 0;

                sanity = 1;
            }
        }

        if (sanity == 2)
        {
            if (temp5 == 0)
            {
                temp5 = addr >> LOG2_BLOCK_SIZE;
                return;
            }
            else if (temp6 == 0)
            {
                temp6 = addr >> LOG2_BLOCK_SIZE;
                return;
            }
            else if (temp7 == 0)
            {
                temp7 = addr >> LOG2_BLOCK_SIZE;
                return;
            }
            else if (temp8 == 0)
            {
                temp8 = addr >> LOG2_BLOCK_SIZE;
                return;
            }

            else
            {
                temp_addr = addr >> LOG2_BLOCK_SIZE;
                stride13 = temp6 - temp5;
                stride14 = temp7 - temp6;
                stride15 = temp8 - temp7;
                stride16 = temp_addr - temp8;

                temp5 = temp_addr;
                temp1 = temp_addr;

                temp6 = 0;
                temp7 = 0;
                temp8 = 0;

                if (flag == 0) // inserting
                {

                    bool anyNonZeroGlobalStride = false;
                    for (int i = 0; i < 16; ++i)
                    {
                        if (globalStrides[i] != 0)
                        {
                            anyNonZeroGlobalStride = true;
                            break;
                        }
                    }

                    if (anyNonZeroGlobalStride || stride13 != 0 || stride14 != 0 || stride15 != 0 || stride16 != 0)
                    {
                        trie.insert(std::make_tuple(
                            globalStrides[0], globalStrides[1], globalStrides[2], globalStrides[3], globalStrides[4], globalStrides[5], globalStrides[6], globalStrides[7],
                            globalStrides[8], globalStrides[9], globalStrides[10], globalStrides[11], globalStrides[12], globalStrides[13], globalStrides[14], globalStrides[15],
                            stride13, stride14, stride15, stride16));
                    }
                    // std:: cout << "Inserting" << std::endl;
                    temp5 = 0;
                    sanity = 0;
                }
                else // checking next 4 offsets
                {
                    if ((stride13 == std::get<0>(*globalNextFourElements) && globalNextFourElements != nullptr) && (stride14 == std::get<1>(*globalNextFourElements) && globalNextFourElements != nullptr) && (stride15 == std::get<2>(*globalNextFourElements) && globalNextFourElements != nullptr) && (stride16 == std::get<3>(*globalNextFourElements) && globalNextFourElements != nullptr))
                    {
                        // std::cout << "Match Found" << std::endl;
                        matched++;
                        trie.incrementReward(globalGroupRootNode, *globalNextFourElements);
                        bool anyNonZeroGlobalStride = false;
                        for (int i = 0; i < 16; ++i)
                        {
                            if (globalStrides[i] != 0)
                            {
                                anyNonZeroGlobalStride = true;
                                break;
                            }
                        }

                        if (anyNonZeroGlobalStride || stride13 != 0 || stride14 != 0 || stride15 != 0 || stride16 != 0)
                        {
                            trie.insert(std::make_tuple(
                                globalStrides[0], globalStrides[1], globalStrides[2], globalStrides[3], globalStrides[4], globalStrides[5], globalStrides[6], globalStrides[7],
                                globalStrides[8], globalStrides[9], globalStrides[10], globalStrides[11], globalStrides[12], globalStrides[13], globalStrides[14], globalStrides[15],
                                stride13, stride14, stride15, stride16));
                        }
                        // update potential
                        trie.update20thNodePotential(globalGroupRootNode, 0);

                        // update maxPotential and nextFourElementsummary
                        trie.updateGroupRootNode(globalGroupRootNode);
                    }

                    else
                    {
                        trie.decrementReward(globalGroupRootNode, *globalNextFourElements);
                        // std::cout << "Not found" << std::endl;
                        bool anyNonZeroGlobalStride = false;
                        for (int i = 0; i < 16; ++i)
                        {
                            if (globalStrides[i] != 0)
                            {
                                anyNonZeroGlobalStride = true;
                                break;
                            }
                        }

                        if (anyNonZeroGlobalStride || stride13 != 0 || stride14 != 0 || stride15 != 0 || stride16 != 0)
                        {
                            trie.insert(std::make_tuple(
                                globalStrides[0], globalStrides[1], globalStrides[2], globalStrides[3], globalStrides[4], globalStrides[5], globalStrides[6], globalStrides[7],
                                globalStrides[8], globalStrides[9], globalStrides[10], globalStrides[11], globalStrides[12], globalStrides[13], globalStrides[14], globalStrides[15],
                                stride13, stride14, stride15, stride16));
                        }

                        // update potential
                        trie.update20thNodePotential(globalGroupRootNode, 0);

                        // update maxPotential and nextFourElementsummary
                        trie.updateGroupRootNode(globalGroupRootNode);
                    }
                    sanity = 1;
                    stride1 = globalStrides[4];
                    stride2 = globalStrides[5];
                    stride3 = globalStrides[6];
                    stride4 = globalStrides[7];
                    stride5 = globalStrides[8];
                    stride6 = globalStrides[9];
                    stride7 = globalStrides[10];
                    stride8 = globalStrides[11];
                    stride9 = globalStrides[12];
                    stride10 = globalStrides[13];
                    stride11 = globalStrides[14];
                    stride12 = globalStrides[15];
                }
            }
        }

        if (sanity == 1)
        {

            globalStrides[0] = stride1;
            globalStrides[1] = stride2;
            globalStrides[2] = stride3;
            globalStrides[3] = stride4;
            globalStrides[4] = stride5;
            globalStrides[5] = stride6;
            globalStrides[6] = stride7;
            globalStrides[7] = stride8;
            globalStrides[8] = stride9;
            globalStrides[9] = stride10;
            globalStrides[10] = stride11;
            globalStrides[11] = stride12;
            globalStrides[12] = stride13;
            globalStrides[13] = stride14;
            globalStrides[14] = stride15;
            globalStrides[15] = stride16;

            trie.queryNextElementsForHighestCountGroup(
                globalStrides[0], globalStrides[1], globalStrides[2], globalStrides[3], globalStrides[4], globalStrides[5], globalStrides[6], globalStrides[7],
                globalStrides[8], globalStrides[9], globalStrides[10], globalStrides[11], globalStrides[12], globalStrides[13], globalStrides[14], globalStrides[15]);

            // std:: cout << globalGroupRootNode << std::endl;
            // std:: cout << globalNextElements << std::endl;

            if (globalGroupRootNode != nullptr && globalNextFourElements != nullptr)
            {
                int64_t nextElement1 = std::get<0>(*globalNextFourElements);
                int64_t nextElement2 = std::get<1>(*globalNextFourElements);
                int64_t nextElement3 = std::get<2>(*globalNextFourElements);
                int64_t nextElement4 = std::get<3>(*globalNextFourElements);

                // std::cout << "Prefetched : " << nextElement1 << " " << nextElement2 << " " << nextElement3 << std::endl;
                // Use nextElement1 and nextElement2 as needed

                prefetch1 = temp_addr + nextElement1;
                prefetch2 = temp_addr + nextElement1 + nextElement2;
                prefetch3 = temp_addr + nextElement1 + nextElement2 + nextElement3;
                prefetch4 = temp_addr + nextElement1 + nextElement2 + nextElement3 + nextElement4;

                prefetch1 = prefetch1 << LOG2_BLOCK_SIZE;
                prefetch2 = prefetch2 << LOG2_BLOCK_SIZE;
                prefetch3 = prefetch3 << LOG2_BLOCK_SIZE;
                prefetch4 = prefetch4 << LOG2_BLOCK_SIZE;

                // std::cout << "Prefetching" << std::endl;
                prefetch_line(ip, addr, prefetch1, FILL_L1, 0);
                prefetch_line(ip, addr, prefetch2, FILL_L1, 0);
                prefetch_line(ip, addr, prefetch3, FILL_L1, 0);
                prefetch_line(ip, addr, prefetch4, FILL_L1, 0);

                // std::cout << "(" << globalStride1 << ", " << globalStride2 << ", " << globalStride3 << ", " << nextElement1 << ", " << nextElement2 << ", " << nextElement3 << ")   " << globalGroupRootNode->nextFourElementsSummary[0].second << "    " << globalGroupRootNode->maxPotential << std::endl;
                prefetched++;

                sanity = 2;
                flag = 1;
            }
            else
            {
                flag = 0;
                sanity = 2;
            }
        }
    }
}

void CACHE::l1d_prefetcher_notify_about_dtlb_eviction(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
}

void CACHE::l1d_prefetcher_cache_fill(uint64_t v_addr, uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t v_evicted_addr, uint64_t evicted_addr, uint32_t metadata_in)
{

#ifdef TRACE_DUMP
    cout << "FILL:  CL Addr: " << (addr >> LOG2_BLOCK_SIZE) << "  Prefetch: " << unsigned(prefetch) << "  Cycle: " << current_core_cycle[cpu] << endl;
#endif
}

void CACHE::l1d_prefetcher_final_stats()
{
    std::cout << "Completed " << std::endl;
    std::cout << "Accuracy : " << (static_cast<double>(matched) / prefetched) * 100 << std::endl;
    std::cout << "Number of unique groups: " << n_total << std::endl;
}
